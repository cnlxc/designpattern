package algorithms.sort;

/**
 * Created by 82138 on 2018/10/8.
 */
public class ShellSort extends Example {
    @Override
    public void sort(Comparable[] a) {
        int N = a.length;
        int h = 1;
        while(h<N/3) h=h*3+1;//h=1,4,13,40,121,364,1093...
        //考虑插入排序的极端情况，最小的一个值在最右边，则对该值要进行N-1次向左移动，有没有办法
        //让这个最小值直接跟最左边的值进行交换呢？希尔排序的方法是把一个数组分成两块，只对第二块的元素进行向左大步移动
        //例如一个23个元素的数组，先分成两块，一块到a[12]，一块从a[13]到a[22]，这样第一次插入排序只用比较a[0],a[13]，若a[13]小于a[0]
        //则直接交换a[12]和a[0],相比于插入排序，少比较了向左一步一步移动的12次,next a[13],a[1]---a[14],a[2]
        //然后进行第二次插入排序，这次用a[4]分开，a[4]后面的全部按四个四个向左移动
        //a[4] a[0]比较  a[5][1]  6,2 (把第6位向左隔四位移，只有一个2能移) 7,3（同左）  8,4,0（到这位的时候就能向左移动两位了）----15,11,7,3（15位可以通过四次直接移动到第3位）
        //第三次插入排序，间隔再变小，变成1，因为已经进行过前面的分块插入排序，最后一此排序虽然是一位一位移动，但已经大大减少了需要移动的次数，而且最后一次移动间隔必须是一，才能保证所有元素都进行了排序
        while(h>=1){
            for(int i =h;i<N;i++) {
                for(int j = i;j>=h&&less(a[j],a[j-h]);j=j-h)
                    exch(a,j,j-h);
            }
            h=h/3;
        }
    }
}
